-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of the Factor programming lanugage with a feature set reduced to be suitable for microcontrollers
--   
--   Please see the README on GitHub at
--   <a>https://github.com/ob-fun-ws18/microFactor#readme</a>
@package microfactor
@version 0.1.0.0


-- | Common data structures
module MicroFactor.Data

-- | The values that can be used in microfactor computations
data TaggedValue r
Boolean :: Bool -> TaggedValue r
Integer :: Word -> TaggedValue r
PortAddress :: Word -> TaggedValue r
Instruction :: MicroFactorInstruction r -> TaggedValue r

-- | A data type for instructions to be interpreted. It is generic over the
--   type of values to be called
data MicroFactorInstruction r

-- | code annotation, does nothing
Comment :: String -> MicroFactorInstruction r

-- | debug output
LiteralString :: String -> MicroFactorInstruction r

-- | put value on stack
Literal :: TaggedValue r -> MicroFactorInstruction r

-- | call other things
Call :: r -> MicroFactorInstruction r

-- | operate on the stack(s)
Operator :: MicroFactorOperator -> MicroFactorInstruction r

-- | The basic opcodes of the language
data MicroFactorOperator
Execute :: MicroFactorOperator
Debugger :: MicroFactorOperator
ControlIte :: MicroFactorOperator
ControlIf :: MicroFactorOperator
ControlDo :: MicroFactorOperator
ControlWhen :: MicroFactorOperator
ControlUnless :: MicroFactorOperator
ControlForever :: MicroFactorOperator
ControlLoop :: MicroFactorOperator
ControlWhile :: MicroFactorOperator
ControlUntil :: MicroFactorOperator
ControlDip :: MicroFactorOperator
ControlKeep :: MicroFactorOperator
LogicNot :: MicroFactorOperator
LogicNor :: MicroFactorOperator
LogicLt :: MicroFactorOperator
LogicGt :: MicroFactorOperator
LogicXor :: MicroFactorOperator
LogicNand :: MicroFactorOperator
LogicAnd :: MicroFactorOperator
LogicXnor :: MicroFactorOperator
LogicLte :: MicroFactorOperator
LogicGte :: MicroFactorOperator
LogicOr :: MicroFactorOperator
StackNip :: MicroFactorOperator
StackDrop :: MicroFactorOperator
StackPick :: MicroFactorOperator
StackDuplicate :: MicroFactorOperator
StackOver :: MicroFactorOperator
StackTuck :: MicroFactorOperator
StackRoll :: MicroFactorOperator
StackSwap :: MicroFactorOperator
StackRotate :: MicroFactorOperator
ArithAdd :: MicroFactorOperator
ArithSub :: MicroFactorOperator
ArithMul :: MicroFactorOperator
ArithDiv :: MicroFactorOperator
ArithMod :: MicroFactorOperator
ArithDivmod :: MicroFactorOperator
ArithAbs :: MicroFactorOperator
ArithMax :: MicroFactorOperator
ArithMin :: MicroFactorOperator
Send :: MicroFactorOperator

-- | A typeclass for references to instructions so that the interpreter
--   might be generic
class InstructionRef a

-- | create a reference for anonymous blocks
makeRef :: InstructionRef a => [MicroFactorInstruction a] -> a

-- | get the referenced list of instruction
resolveRef :: InstructionRef a => a -> [MicroFactorInstruction a]

-- | refer to the instructions by name, instead of treating them as
--   anonymous
refName :: InstructionRef a => a -> String

-- | the most simple implementation of <a>InstructionRef</a> while avoiding
--   infinite types
data Nested
instance GHC.Show.Show MicroFactor.Data.Nested
instance Data.Traversable.Traversable MicroFactor.Data.TaggedValue
instance Data.Foldable.Foldable MicroFactor.Data.TaggedValue
instance GHC.Base.Functor MicroFactor.Data.TaggedValue
instance MicroFactor.Data.InstructionRef r => GHC.Show.Show (MicroFactor.Data.TaggedValue r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (MicroFactor.Data.TaggedValue r)
instance Data.Traversable.Traversable MicroFactor.Data.MicroFactorInstruction
instance Data.Foldable.Foldable MicroFactor.Data.MicroFactorInstruction
instance GHC.Base.Functor MicroFactor.Data.MicroFactorInstruction
instance GHC.Classes.Eq r => GHC.Classes.Eq (MicroFactor.Data.MicroFactorInstruction r)
instance GHC.Enum.Bounded MicroFactor.Data.MicroFactorOperator
instance GHC.Enum.Enum MicroFactor.Data.MicroFactorOperator
instance GHC.Classes.Ord MicroFactor.Data.MicroFactorOperator
instance GHC.Classes.Eq MicroFactor.Data.MicroFactorOperator
instance MicroFactor.Data.InstructionRef MicroFactor.Data.Nested
instance MicroFactor.Data.InstructionRef r => GHC.Show.Show (MicroFactor.Data.MicroFactorInstruction r)
instance GHC.Base.Applicative MicroFactor.Data.MicroFactorInstruction
instance GHC.Base.Monad MicroFactor.Data.MicroFactorInstruction
instance GHC.Show.Show MicroFactor.Data.MicroFactorOperator


-- | Runtime and interpreter for MicroFactor bytecode
module MicroFactor.Interpreter

-- | Interpret a sequence of instructions on a thread. Creates output and
--   affects the thread, and can fail with an error.
interpret :: InstructionRef a => [MicroFactorInstruction a] -> Thread a -> InterpreterResult a ()

-- | Things that can go wrong during interpretion
data InterpreterError

-- | an attempt was made to pop from the empty (data) stack
StackUnderflow :: InterpreterError

-- | an operation required an <a>Instruction</a> but was given some other
--   value
InvalidExecutionToken :: InterpreterError

-- | some other operation did get the wrong operands
TypeError :: String -> InterpreterError

-- | Possible state for cooperative threads (not yet implemented)
data ThreadState
Running :: ThreadState
Delayed :: ThreadState
Yielded :: ThreadState
Waiting :: ThreadState

-- | The result of executing instructions
data InterpreterResult r a
InterpreterResult :: [String] -> Thread r -> Either InterpreterError a -> InterpreterResult r a

-- | debug and <a>Send</a> output from the execution
[interpreterOutput] :: InterpreterResult r a -> [String]

-- | the new state of the thread
[interpreterThread] :: InterpreterResult r a -> Thread r

-- | the result value of the current step
[interpreterValue] :: InterpreterResult r a -> Either InterpreterError a

-- | A structure representing a cooperative thread (that might be
--   suspended)
data Thread r
Thread :: ThreadState -> [TaggedValue r] -> [r] -> Thread r
[state] :: Thread r -> ThreadState
[dataStack] :: Thread r -> [TaggedValue r]
[returnStack] :: Thread r -> [r]

-- | A fresh new thread, ready to run instructions
newThread :: Thread r

-- | shortened representation of <a>TaggedValue</a>s
showValue :: TaggedValue a -> String
instance GHC.Base.Functor (MicroFactor.Interpreter.ThreadInterpreter r)
instance (MicroFactor.Data.InstructionRef r, GHC.Show.Show r, GHC.Show.Show a) => GHC.Show.Show (MicroFactor.Interpreter.InterpreterResult r a)
instance (MicroFactor.Data.InstructionRef r, GHC.Show.Show r) => GHC.Show.Show (MicroFactor.Interpreter.Thread r)
instance GHC.Show.Show MicroFactor.Interpreter.ThreadState
instance GHC.Classes.Eq MicroFactor.Interpreter.ThreadState
instance GHC.Show.Show MicroFactor.Interpreter.InterpreterError
instance GHC.Classes.Eq MicroFactor.Interpreter.InterpreterError
instance GHC.Base.Applicative (MicroFactor.Interpreter.ThreadInterpreter r)
instance GHC.Base.Monad (MicroFactor.Interpreter.ThreadInterpreter r)
instance GHC.Base.Functor (MicroFactor.Interpreter.InterpreterResult r)


-- | Parse string to bytecode and resolve identifiers to other functions
module MicroFactor.Parser

-- | The references to callables that the parser emits
data ParsedRef

-- | a parenthised code block
Anonymous :: [MicroFactorInstruction ParsedRef] -> ParsedRef

-- | an identifier
Named :: SourcePos -> String -> ParsedRef

-- | An optionally named reference to more instructions
data ResolvedRef
ResolvedRef :: String -> [MicroFactorInstruction ResolvedRef] -> ResolvedRef

-- | A parser for an expression, i.e. an instruction sequence with at least
--   one element
expressionParser :: Parser [MicroFactorInstruction ParsedRef]

-- | The various commands available on the REPL
data Command
Quit :: Command
List :: Command
Define :: String -> [MicroFactorInstruction ParsedRef] -> Command
Evaluate :: [MicroFactorInstruction ParsedRef] -> Command
ShowDef :: String -> Command
Load :: Maybe String -> Command
Save :: Maybe String -> Command

-- | A lookup map of all the available <a>Operator</a>s from their names,
--   including the two boolean literals
builtinSymbols :: InstructionRef r => Map String (MicroFactorInstruction r)

-- | A parser for a sequence of commands
commandParser :: Parser [Command]
dictionaryParser :: Parser [(String, [MicroFactorInstruction ParsedRef])]

-- | A <a>Map</a> of available functions
type MicroFactorScope = Map String [MicroFactorInstruction ResolvedRef]

-- | show the definitions that created the scope, line by line
formatScope :: MicroFactorScope -> String

-- | Try to resolve the <a>Named</a> <a>ParsedRef</a>s in a
--   <a>MicroFactorInstruction</a> sequence. Uses the <a>builtinSymbols</a>
--   or a lookup in the supplied scope, emitting an <i>unknown
--   identifier</i> message if it fails for any
resolve :: MicroFactorScope -> [MicroFactorInstruction ParsedRef] -> Either ParseError [MicroFactorInstruction ResolvedRef]

-- | Add a function definition to the scope. Uses <a>resolve</a>, but also
--   supports recursive definitions to the new function itself. TODO: Does
--   not yet update references when redefining an existing name
define :: String -> [MicroFactorInstruction ParsedRef] -> MicroFactorScope -> Either ParseError MicroFactorScope

-- | show the <a>errorMessages</a> of a <a>ParseError</a> only (not its
--   <a>errorPos</a>). Otherwise very similar to the <a>Show</a> instance.
--   Notice the leading linebreak!
formatErrorMessages :: ParseError -> String
instance GHC.Show.Show MicroFactor.Parser.Command
instance GHC.Classes.Eq MicroFactor.Parser.Command
instance GHC.Classes.Eq MicroFactor.Parser.ResolvedRef
instance GHC.Show.Show MicroFactor.Parser.ParsedRef
instance GHC.Classes.Eq MicroFactor.Parser.ParsedRef
instance MicroFactor.Data.InstructionRef MicroFactor.Parser.ResolvedRef
instance GHC.Show.Show MicroFactor.Parser.ResolvedRef
instance MicroFactor.Data.InstructionRef MicroFactor.Parser.ParsedRef

module MicroFactor
